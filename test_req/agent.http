### Aplicar plantilla de chat

# POST http://ia:8080/chat/completions
POST http://ia:8080/chat/completions
Content-Type: application/json

{
  "messages": [
    {
      "role": "system",
      "content": "You are a systematic coding agent. Break down problems methodically."
    },
    { "role": "user", "content": "explicame el readme" }
  ],
  "model": "Qwen3-Coder-30B-A3B-Instruct",
  "max_tokens": 4096,
  "stream": true,
  "tools": [
    {
      "type": "function",
      "function": {
        "name": "read_file",
        "description": "Use this tool if you need to view the contents of an existing file.",
        "parameters": {
          "type": "object",
          "required": ["filepath"],
          "properties": {
            "filepath": {
              "type": "string",
              "description": "The path of the file to read, relative to the root of the workspace (NOT uri or absolute path)"
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "create_new_file",
        "description": "Create a new file. Only use this when a file doesn't exist and should be created",
        "parameters": {
          "type": "object",
          "required": ["filepath", "contents"],
          "properties": {
            "filepath": {
              "type": "string",
              "description": "The path where the new file should be created, relative to the root of the workspace"
            },
            "contents": {
              "type": "string",
              "description": "The contents to write to the new file"
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "run_terminal_command",
        "description": "Run a terminal command in the current directory.\nThe shell is not stateful and will not remember any previous commands.      When a command is run in the background ALWAYS suggest using shell commands to stop it; NEVER suggest using Ctrl+C.      When suggesting subsequent shell commands ALWAYS format them in shell command blocks.      Do NOT perform actions requiring special/admin privileges.      Choose terminal commands and scripts optimized for linux and x64 and shell /bin/bash.",
        "parameters": {
          "type": "object",
          "required": ["command"],
          "properties": {
            "command": {
              "type": "string",
              "description": "The command to run. This will be passed directly into the IDE shell."
            },
            "waitForCompletion": {
              "type": "boolean",
              "description": "Whether to wait for the command to complete before returning. Default is true. Set to false to run the command in the background. Set to true to run the command in the foreground and wait to collect the output."
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "file_glob_search",
        "description": "Search for files recursively in the project using glob patterns. Supports ** for recursive directory search. Will not show many build, cache, secrets dirs/files (can use ls tool instead). Output may be truncated; use targeted patterns",
        "parameters": {
          "type": "object",
          "required": ["pattern"],
          "properties": {
            "pattern": {
              "type": "string",
              "description": "Glob pattern for file path matching"
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "view_diff",
        "description": "View the current diff of working changes",
        "parameters": { "type": "object", "properties": {} }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "read_currently_open_file",
        "description": "Read the currently open file in the IDE. If the user seems to be referring to a file that you can't see, or is requesting an action on content that seems missing, try using this tool.",
        "parameters": { "type": "object", "properties": {} }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "ls",
        "description": "List files and folders in a given directory",
        "parameters": {
          "type": "object",
          "properties": {
            "dirPath": {
              "type": "string",
              "description": "The directory path relative to the root of the project. Use forward slash paths like '/'. rather than e.g. '.'"
            },
            "recursive": {
              "type": "boolean",
              "description": "If true, lists files and folders recursively. To prevent unexpected large results, use this sparingly"
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "create_rule_block",
        "description": "Creates a \"rule\" that can be referenced in future conversations. This should be used whenever you want to establish code standards / preferences that should be applied consistently, or when you want to avoid making a mistake again. To modify existing rules, use the edit tool instead.\n\nRule Types:\n- Always: Include only \"rule\" (always included in model context)\n- Auto Attached: Include \"rule\", \"globs\", and/or \"regex\" (included when files match patterns)\n- Agent Requested: Include \"rule\" and \"description\" (AI decides when to apply based on description)\n- Manual: Include only \"rule\" (only included when explicitly mentioned using @ruleName)",
        "parameters": {
          "type": "object",
          "required": ["name", "rule"],
          "properties": {
            "name": {
              "type": "string",
              "description": "Short, descriptive name summarizing the rule's purpose (e.g. 'React Standards', 'Type Hints')"
            },
            "rule": {
              "type": "string",
              "description": "Clear, imperative instruction for future code generation (e.g. 'Use named exports', 'Add Python type hints'). Each rule should focus on one specific standard."
            },
            "description": {
              "type": "string",
              "description": "Description of when this rule should be applied. Required for Agent Requested rules (AI decides when to apply). Optional for other types."
            },
            "globs": {
              "type": "string",
              "description": "Optional file patterns to which this rule applies (e.g. ['**/*.{ts,tsx}'] or ['src/**/*.ts', 'tests/**/*.ts'])"
            },
            "regex": {
              "type": "string",
              "description": "Optional regex patterns to match against file content. Rule applies only to files whose content matches the pattern (e.g. 'useEffect' for React hooks or '\\bclass\\b' for class definitions)"
            },
            "alwaysApply": {
              "type": "boolean",
              "description": "Whether this rule should always be applied. Set to false for Agent Requested and Manual rules. Omit or set to true for Always and Auto Attached rules."
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "fetch_url_content",
        "description": "Can be used to view the contents of a website using a URL. Do NOT use this for files.",
        "parameters": {
          "type": "object",
          "required": ["url"],
          "properties": {
            "url": { "type": "string", "description": "The URL to read" }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "request_rule",
        "description": "Use this tool to retrieve additional 'rules' that contain more context/instructions based on their descriptions. Available rules:\nNo rules available.",
        "parameters": {
          "type": "object",
          "required": ["name"],
          "properties": {
            "name": { "type": "string", "description": "Name of the rule" }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "edit_existing_file",
        "description": "Use this tool to edit an existing file. If you don't know the contents of the file, read it first.\n  When addressing code modification requests, present a concise code snippet that\n  emphasizes only the necessary changes and uses abbreviated placeholders for\n  unmodified sections. For example:\n\n  ```language /path/to/file\n  // ... existing code ...\n\n  {{modified code here}}\n\n  // ... existing code ...\n\n  {{another modification}}\n\n  // ... rest of code ...\n  ```\n\n  In existing files, you should always restate the function or class that the snippet belongs to:\n\n  ```language /path/to/file\n  // ... existing code ...\n\n  function exampleFunction() {\n    // ... existing code ...\n\n    {{modified code here}}\n\n    // ... rest of function ...\n  }\n\n  // ... rest of code ...\n  ```\n\n  Since users have access to their complete file, they prefer reading only the\n  relevant modifications. It's perfectly acceptable to omit unmodified portions\n  at the beginning, middle, or end of files using these \"lazy\" comments. Only\n  provide the complete file when explicitly requested. Include a concise explanation\n  of changes unless the user specifically asks for code only.\n\nThis tool CANNOT be called in parallel with other tools.",
        "parameters": {
          "type": "object",
          "required": ["filepath", "changes"],
          "properties": {
            "filepath": {
              "type": "string",
              "description": "The path of the file to edit, relative to the root of the workspace."
            },
            "changes": {
              "type": "string",
              "description": "Any modifications to the file, showing only needed changes. Do NOT wrap this in a codeblock or write anything besides the code changes. In larger files, use brief language-appropriate placeholders for large unmodified sections, e.g. '// ... existing code ...'"
            }
          }
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "single_find_and_replace",
        "description": "Performs exact string replacements in a file.\n\nIMPORTANT:\n- ALWAYS use the `read_file` tool just before making edits, to understand the file's up-to-date contents and context. The user can also edit the file while you are working with it.\n- This tool CANNOT be called in parallel with other tools.\n- When editing text from `read_file` tool output, ensure you preserve exact whitespace/indentation.\n- Only use emojis if the user explicitly requests it. Avoid adding emojis to files unless asked.\n- Use `replace_all` for replacing and renaming strings across the file. This parameter is useful if you want to rename a variable, for instance.\n\nWARNINGS:\n- When not using `replace_all`, the edit will FAIL if `old_string` is not unique in the file. Either provide a larger string with more surrounding context to make it unique or use `replace_all` to change every instance of `old_string`.\n- The edit will likely fail if you have not recently used the `read_file` tool to view up-to-date file contents.",
        "parameters": {
          "type": "object",
          "required": ["filepath", "old_string", "new_string"],
          "properties": {
            "filepath": {
              "type": "string",
              "description": "The path to the file to modify, relative to the root of the workspace"
            },
            "old_string": {
              "type": "string",
              "description": "The text to replace - must be exact including whitespace/indentation"
            },
            "new_string": {
              "type": "string",
              "description": "The text to replace it with (MUST be different from old_string)"
            },
            "replace_all": {
              "type": "boolean",
              "description": "Replace all occurrences of old_string (default false)"
            }
          }
        }
      }
    }
  ],
  "parallel_tool_calls": false,
  "stream_options": { "include_usage": true }
}


###
# 2-POST http://ia:8080/chat/completions
POST http://ia:8080/v1/chat/completions
Content-Type: application/json

{
  "model": "Qwen3-Coder-30B-A3B-Instruct",
  "max_tokens": 4096,
  "stream": true,
  "messages": [
    {
      "role": "system",
      "content": "You are a systematic coding agent. Break down problems methodically."
    },
    {
      "role": "user",
      "content": "explicame el readme"
    },
    {
      "role": "assistant",
      "tool_calls": [
        {
          "id": "bW2QY7y7sA2XArriAKliIa29URjwMB9n",
          "type": "function",
          "function": {
            "name": "read_file",
            "arguments": "{\"filepath\":\"/README.md\"}"
          }
        }
      ]
    },
    {
      "role": "tool",
      "tool_call_id": "bW2QY7y7sA2XArriAKliIa29URjwMB9n",
      "content": "# 🚀 Proyecto IA - Docker & DevContainer\n\nEste proyecto provee un entorno DevContainer optimizado para agentes de IA locales. Permite montar modelos como Qwen, Llama o Mistral con soporte para herramientas y ejecución directa desde VSCode usando la extensión Continue.\n\n## 🧠 Características principales\n- Configuración automática de dependencias\n- Ejecución local sin conexión a la nube\n- Soporte para agentes con tools (read_file, edit_file, run_terminal_command, etc.)\n\n## 🛠️ Cómo usar\n1. Abre la carpeta en VSCode\n2. Reconstruye el contenedor DevContainer (`Ctrl+Shift+P → Reopen in DevContainer`)\n3. Usa la extensión Continue para interactuar con el modelo\n\n## ⚙️ Modelos soportados\n- Qwen3-Coder\n- Llama3\n- Mistral 7B/8x7B\n\n## 📦 Estructura\n```\n/.devcontainer\n/workspace\n  ├── config.yaml\n  ├── globalContext.json\n  ├── docker-compose.yml\n```\n\n---\nEste template está diseñado para facilitar la experimentación con agentes inteligentes en entornos reproducibles."
    }
  ],
  "stream_options": { "include_usage": true }
}
